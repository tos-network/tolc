use std::fs;
use std::path::{Path, PathBuf};
use tolc::parser::parse_and_verify;
use std::env;
use tolc::codegen::{ClassWriter, class_file_to_bytes};
use tolc::ast::TypeDecl;

fn java_root() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("tests").join("java")
}

#[test]
/// Test TOLC's bytecode generation alignment with javac
/// 
/// This test does NOT verify compilation success (TOLC already compiles successfully).
/// Instead, it compares the generated bytecode with javac's reference output using javap.
/// 
/// When this test fails, it means:
/// 1. TOLC compiled the Java source successfully ✅
/// 2. But the generated bytecode differs from javac's patterns ❌
/// 3. We need to align TOLC's bytecode generation with javac's optimization patterns
/// 
/// This is a bytecode alignment test, not a compilation test.
fn parse_all_java_files_under_tests_java() {
    // Initialize logger for diagnostics
    let _ = env_logger::builder()
        .is_test(true)
        .format_timestamp_millis()
        .filter_level(log::LevelFilter::Debug)
        .try_init();
    let root = java_root();
    assert!(root.exists(), "tests/java directory not found: {}", root.display());

    // Reference compiled classes root for javap parity comparison
    // These are javac-generated .class files that serve as the "gold standard"
    let ref_root = classes_root();
    assert!(ref_root.exists(), "tests/classes/java not found: {}", ref_root.display());

    // Ensure classpath and compatibility mode are set when running under `cargo test`
    if env::var("TOLC_CLASSPATH").is_err() { env::set_var("TOLC_CLASSPATH", root.display().to_string()); }
    if env::var("TOLC_CLASSPATH_MAX_FILES").is_err() { env::set_var("TOLC_CLASSPATH_MAX_FILES", "60"); }
    if env::var("TOLC_CLASSPATH_MAX_FILE_SIZE").is_err() { env::set_var("TOLC_CLASSPATH_MAX_FILE_SIZE", "65536"); }
    if env::var("TOLC_JAVAC_COMPAT").is_err() { env::set_var("TOLC_JAVAC_COMPAT", "1"); }

    // Configuration for segmented testing
    let filter = std::env::var("JAVA_SUITE_FILTER").ok();
    let filter_file = std::env::var("TOLC_FILTER_FILE").ok();
    
    // Segment configuration - run tests in chunks
    let segment_size = std::env::var("JAVA_SUITE_SEGMENT_SIZE")
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(10); // Default: 10 files per segment
    
    let segment_number = std::env::var("JAVA_SUITE_SEGMENT")
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(0); // Default: first segment
    
    // Limit total number of files to process for faster testing
    let max_files = std::env::var("TOLC_MAXFILES")
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(usize::MAX);
    
    // Timeout configuration
    let timeout_seconds = std::env::var("JAVA_SUITE_TIMEOUT")
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(10); // Default: 10 seconds

    eprintln!("[CONFIG] Segment: {}/?, Size: {}, Max files: {}, Timeout: {}s", 
              segment_number, segment_size, max_files, timeout_seconds);

    let mut bytecode_mismatches: Vec<(String, String)> = Vec::new();
    let mut compared: usize = 0;
    let mut processed: usize = 0;
    let mut skipped: usize = 0;

    // Temp dir for our generated classes
    let out_dir = std::env::temp_dir().join("java_suite_compare");
    let _ = fs::create_dir_all(&out_dir);

    // Predefined file list in specific order (same as java_suite_ordered.rs)
    let file_list = vec![
        "tests/java/util/ArraysComparator.java",
        "tests/java/util/ArraysAbstractList.java",
        "tests/java/util/HashMapMyIterator.java",
        "tests/java/util/LinkedList.java",
        "tests/java/util/Map.java",
        "tests/java/util/BitSet.java",
        "tests/java/util/Objects.java",
        "tests/java/util/UnmodifiableIterator.java",
        "tests/java/util/IterationModificationException.java",
        "tests/java/util/IdentityHashMap.java",
        "tests/java/util/IdentityHashMapMyHelper.java",
        "tests/java/util/HashMap.java",
        "tests/java/util/AbstractSet.java",
        "tests/java/util/UnmodifiableList.java",
        "tests/java/util/Collection.java",
        "tests/java/util/ReverseComparator.java",
        "tests/java/util/SynchronizedList.java",
        "tests/java/util/HashMapCell.java",
        "tests/java/util/List.java",
        "tests/java/util/MaskInfo.java",
        "tests/java/util/UnmodifiableMap.java",
        "tests/java/util/HashMapHelper.java",
        "tests/java/util/ArrayListIterator.java",
        "tests/java/util/RandomAccessSynchronizedList.java",
        "tests/java/util/Queue.java",
        "tests/java/util/AbstractList.java",
        "tests/java/util/EnumSetIterator.java",
        "tests/java/util/AbstractSequentialList.java",
        "tests/java/util/SynchronizedMap.java",
        "tests/java/util/EventObject.java",
        "tests/java/util/SynchronizedIterator.java",
        "tests/java/util/LinkedListCell.java",
        "tests/java/util/SynchronizedCollection.java",
        "tests/java/util/HashMapMyEntryMap.java",
        "tests/java/util/HashMapMyHelper.java",
        "tests/java/util/ArrayList.java",
        "tests/java/util/AbstractCollection.java",
        "tests/java/util/LinkedListMyIterator.java",
        "tests/java/util/Iterator.java",
        "tests/java/util/LinkedListDescendingIterator.java",
        "tests/java/util/SynchronizedSet.java",
        "tests/java/util/ArraysListIterator.java",
        "tests/java/util/HashSetMyIterator.java",
        "tests/java/util/UnmodifiableSet.java",
        "tests/java/util/NoSuchElementException.java",
        "tests/java/util/IteratorEnumeration.java",
        "tests/java/util/Deque.java",
        "tests/java/util/Enumeration.java",
        "tests/java/util/AbstractMap.java",
        "tests/java/util/HashSet.java",
        "tests/java/util/EventListener.java",
        "tests/java/util/MaskInfoIterator.java",
        "tests/java/util/CollectionsComparator.java",
        "tests/java/util/Hashtable.java",
        "tests/java/util/UnmodifiableListIterator.java",
        "tests/java/util/IllegalFormatException.java",
        "tests/java/util/Collections.java",
        "tests/java/util/UnmodifiableCollection.java",
        "tests/java/util/EnumSet.java",
        "tests/java/util/Arrays.java",
        "tests/java/util/Comparator.java",
        "tests/java/util/Date.java",
        "tests/java/util/Set.java",
        "tests/java/util/Entry.java",
        "tests/java/util/RandomAccess.java",
        "tests/java/util/ListIterator.java",
        "tests/java/util/HashMapMyCell.java",
        "tests/java/io/PrintStream.java",
        "tests/java/io/UnsupportedEncodingException.java",
        "tests/java/io/ObjectInputStream.java",
        "tests/java/io/SystemPrintStream.java",
        "tests/java/io/ObjectOutputStream.java",
        "tests/java/io/IOException.java",
        "tests/java/io/ByteArrayOutputStreamCell.java",
        "tests/java/io/Flushable.java",
        "tests/java/io/Closeable.java",
        "tests/java/io/Serializable.java",
        "tests/java/io/InputStream.java",
        "tests/java/io/OutputStream.java",
        "tests/java/io/ObjectInputStreamClassDesc.java",
        "tests/java/io/EOFException.java",
        "tests/java/io/ByteArrayInputStream.java",
        "tests/java/io/ByteArrayOutputStream.java",
        "tests/java/io/CharToPrimitiveType.java",
        "tests/java/math/BigInteger.java",
        "tests/java/lang/Int80.java",
        "tests/java/lang/Int216.java",
        "tests/java/lang/Callable.java",
        "tests/java/lang/Int168.java",
        "tests/java/lang/Bytes1.java",
        "tests/java/lang/Int200.java",
        "tests/java/lang/Bytes12.java",
        "tests/java/lang/Int96.java",
        "tests/java/lang/IllegalStateException.java",
        "tests/java/lang/Message.java",
        "tests/java/lang/UnsatisfiedLinkError.java",
        "tests/java/lang/Int152.java",
        "tests/java/lang/System.java",
        "tests/java/lang/Bytes28.java",
        "tests/java/lang/Int144.java",
        "tests/java/lang/NullPointerException.java",
        "tests/java/lang/StringBuilder.java",
        "tests/java/lang/NumericArrays.java",
        "tests/java/lang/AutoCloseable.java",
        "tests/java/lang/Integer.java",
        "tests/java/lang/Bytes32.java",
        "tests/java/lang/contract/Contract.java",
        "tests/java/lang/contract/IERC20.java",
        "tests/java/lang/contract/ERC20.java",
        "tests/java/lang/contract/ERC20InsufficientAllowance.java",
        "tests/java/lang/contract/ERC20InvalidApprover.java",
        "tests/java/lang/contract/ERC20InvalidSpender.java",
        "tests/java/lang/contract/IERC20Metadata.java",
        "tests/java/lang/contract/ERC20TokenPaused.java",
        "tests/java/lang/contract/ERC20InvalidSender.java",
        "tests/java/lang/contract/OnlyOwner.java",
        "tests/java/lang/contract/ERC20InsufficientBalance.java",
        "tests/java/lang/contract/ERC20InvalidAmount.java",
        "tests/java/lang/contract/IERC20Errors.java",
        "tests/java/lang/contract/ERC20InvalidReceiver.java",
        "tests/java/lang/Bytes24.java",
        "tests/java/lang/NoSuchFieldException.java",
        "tests/java/lang/IllegalAccessException.java",
        "tests/java/lang/Bytes25.java",
        "tests/java/lang/AssertionError.java",
        "tests/java/lang/ThreadDeath.java",
        "tests/java/lang/Iterable.java",
        "tests/java/lang/StackTraceElement.java",
        "tests/java/lang/Uint256.java",
        "tests/java/lang/SecurityException.java",
        "tests/java/lang/VirtualMachineError.java",
        "tests/java/lang/Exception.java",
        "tests/java/lang/Int112.java",
        "tests/java/lang/StringBuffer.java",
        "tests/java/lang/Bytes29.java",
        "tests/java/lang/bytes/Type.java",
        "tests/java/lang/bytes/Hex.java",
        "tests/java/lang/bytes/Division.java",
        "tests/java/lang/Uint128.java",
        "tests/java/lang/StringBuilderCell.java",
        "tests/java/lang/Int104.java",
        "tests/java/lang/SystemNanoTime.java",
        "tests/java/lang/Int128.java",
        "tests/java/lang/RevertException.java",
        "tests/java/lang/Bytes13.java",
        "tests/java/lang/Int256.java",
        "tests/java/lang/UintType.java",
        "tests/java/lang/Int240.java",
        "tests/java/lang/Byte.java",
        "tests/java/lang/Int32.java",
        "tests/java/lang/Paused.java",
        "tests/java/lang/Int24.java",
        "tests/java/lang/StringIndexOutOfBoundsException.java",
        "tests/java/lang/Bytes18.java",
        "tests/java/lang/AbstractMethodError.java",
        "tests/java/lang/Short.java",
        "tests/java/lang/Bytes22.java",
        "tests/java/lang/OutOfMemoryError.java",
        "tests/java/lang/Bytes.java",
        "tests/java/lang/invoke/MethodHandlesLookup.java",
        "tests/java/lang/invoke/MethodTypeResult.java",
        "tests/java/lang/invoke/MethodType.java",
        "tests/java/lang/invoke/MethodHandles.java",
        "tests/java/lang/invoke/MethodTypeType.java",
        "tests/java/lang/invoke/MethodTypeTypeSpec.java",
        "tests/java/lang/invoke/MethodHandle.java",
        "tests/java/lang/invoke/MethodTypeParameter.java",
        "tests/java/lang/Void.java",
        "tests/java/lang/Context.java",
        "tests/java/lang/Int.java",
        "tests/java/lang/Bytes7.java",
        "tests/java/lang/StringUtil.java",
        "tests/java/lang/IllegalAccessError.java",
        "tests/java/lang/Bytes14.java",
        "tests/java/lang/reflect/InvocationHandler.java",
        "tests/java/lang/reflect/TypeVariable.java",
        "tests/java/lang/reflect/SignatureParser.java",
        "tests/java/lang/reflect/Method.java",
        "tests/java/lang/reflect/Type.java",
        "tests/java/lang/reflect/Modifier.java",
        "tests/java/lang/reflect/TypeVariableImpl.java",
        "tests/java/lang/reflect/Constructor.java",
        "tests/java/lang/reflect/AccessibleObject.java",
        "tests/java/lang/reflect/TypeVariableImpl1.java",
        "tests/java/lang/reflect/GenericDeclaration.java",
        "tests/java/lang/reflect/AnnotatedElement.java",
        "tests/java/lang/reflect/Array.java",
        "tests/java/lang/reflect/Proxy.java",
        "tests/java/lang/reflect/Member.java",
        "tests/java/lang/reflect/SignatureParserType.java",
        "tests/java/lang/reflect/Field.java",
        "tests/java/lang/reflect/ParameterizedType.java",
        "tests/java/lang/reflect/InvocationTargetException.java",
        "tests/java/lang/CharSequence.java",
        "tests/java/lang/TypeNotPresentException.java",
        "tests/java/lang/Deprecated.java",
        "tests/java/lang/NoSuchMethodError.java",
        "tests/java/lang/NoClassDefFoundError.java",
        "tests/java/lang/Uint8.java",
        "tests/java/lang/Package.java",
        "tests/java/lang/IllegalArgumentException.java",
        "tests/java/lang/IllegalMonitorStateException.java",
        "tests/java/lang/Comparable.java",
        "tests/java/lang/Bytes15.java",
        "tests/java/lang/Bytes6.java",
        "tests/java/lang/ClassNotFoundException.java",
        "tests/java/lang/annotation/External.java",
        "tests/java/lang/annotation/Internal.java",
        "tests/java/lang/annotation/ElementType.java",
        "tests/java/lang/annotation/RetentionPolicy.java",
        "tests/java/lang/annotation/Virtual.java",
        "tests/java/lang/annotation/Constant.java",
        "tests/java/lang/annotation/View.java",
        "tests/java/lang/annotation/Retention.java",
        "tests/java/lang/annotation/Target.java",
        "tests/java/lang/annotation/Payable.java",
        "tests/java/lang/annotation/Pure.java",
        "tests/java/lang/annotation/Annotation.java",
        "tests/java/lang/Long.java",
        "tests/java/lang/Bytes23.java",
        "tests/java/lang/Int48.java",
        "tests/java/lang/EventLog.java",
        "tests/java/lang/Class.java",
        "tests/java/lang/RuntimeException.java",
        "tests/java/lang/Uint16.java",
        "tests/java/lang/Object.java",
        "tests/java/lang/Mapping.java",
        "tests/java/lang/Int72.java",
        "tests/java/lang/Bytes19.java",
        "tests/java/lang/CloneNotSupportedException.java",
        "tests/java/lang/Throwable.java",
        "tests/java/lang/Address.java",
        "tests/java/lang/ClassCastException.java",
        "tests/java/lang/InternalError.java",
        "tests/java/lang/String.java",
        "tests/java/lang/InterruptedException.java",
        "tests/java/lang/Int64.java",
        "tests/java/lang/ReflectiveOperationException.java",
        "tests/java/lang/Uint.java",
        "tests/java/lang/Character.java",
        "tests/java/lang/Bytes20.java",
        "tests/java/lang/Int232.java",
        "tests/java/lang/Int224.java",
        "tests/java/lang/NoSuchFieldError.java",
        "tests/java/lang/Uint160.java",
        "tests/java/lang/Number.java",
        "tests/java/lang/Int208.java",
        "tests/java/lang/Int176.java",
        "tests/java/lang/Bytes9.java",
        "tests/java/lang/Approval.java",
        "tests/java/lang/Int160.java",
        "tests/java/lang/Int88.java",
        "tests/java/lang/LinkageError.java",
        "tests/java/lang/Override.java",
        "tests/java/lang/BytesType.java",
        "tests/java/lang/InstantiationException.java",
        "tests/java/lang/Cloneable.java",
        "tests/java/lang/StringComparator.java",
        "tests/java/lang/ClassLoader.java",
        "tests/java/lang/Bytes16.java",
        "tests/java/lang/Bytes5.java",
        "tests/java/lang/ExceptionInInitializerError.java",
        "tests/java/lang/IntType.java",
        "tests/java/lang/InstantiationError.java",
        "tests/java/lang/Enum.java",
        "tests/java/lang/Bytes4.java",
        "tests/java/lang/Bytes17.java",
        "tests/java/lang/NegativeArraySizeException.java",
        "tests/java/lang/Appendable.java",
        "tests/java/lang/ArrayStoreException.java",
        "tests/java/lang/Int136.java",
        "tests/java/lang/IncompatibleClassChangeError.java",
        "tests/java/lang/Int248.java",
        "tests/java/lang/Bytes8.java",
        "tests/java/lang/SuppressWarnings.java",
        "tests/java/lang/Int120.java",
        "tests/java/lang/Transfer.java",
        "tests/java/lang/Bytes21.java",
        "tests/java/lang/Int16.java",
        "tests/java/lang/ArrayIndexOutOfBoundsException.java",
        "tests/java/lang/Int8.java",
        "tests/java/lang/NumberFormatException.java",
        "tests/java/lang/Bytes10.java",
        "tests/java/lang/Uint64.java",
        "tests/java/lang/Bytes3.java",
        "tests/java/lang/Readable.java",
        "tests/java/lang/Bool.java",
        "tests/java/lang/Bytes26.java",
        "tests/java/lang/Bytes30.java",
        "tests/java/lang/ClassType.java",
        "tests/java/lang/Math.java",
        "tests/java/lang/OwnershipTransferred.java",
        "tests/java/lang/Boolean.java",
        "tests/java/lang/Error.java",
        "tests/java/lang/NumericType.java",
        "tests/java/lang/Runtime.java",
        "tests/java/lang/ArithmeticException.java",
        "tests/java/lang/NoSuchMethodException.java",
        "tests/java/lang/UnsupportedOperationException.java",
        "tests/java/lang/IndexOutOfBoundsException.java",
        "tests/java/lang/Bytes31.java",
        "tests/java/lang/Unpaused.java",
        "tests/java/lang/Bytes27.java",
        "tests/java/lang/Int184.java",
        "tests/java/lang/Int192.java",
        "tests/java/lang/Bytes2.java",
        "tests/java/lang/Bytes11.java",
        "tests/java/lang/Uint32.java",
        "tests/java/lang/SecurityManager.java",
        "tests/java/lang/Int56.java",
        "tests/java/lang/StackOverflowError.java",
        "tests/java/lang/Int40.java",
        "tests/java/base/Callable.java",
        "tests/java/base/DataEntrySet.java",
        "tests/java/base/NameAndTypePoolEntry.java",
        "tests/java/base/MethodAddendum.java",
        "tests/java/base/VMMethod.java",
        "tests/java/base/MethodRefPoolEntry.java",
        "tests/java/base/IncompatibleContinuationException.java",
        "tests/java/base/FieldData.java",
        "tests/java/base/DataKeyIterator.java",
        "tests/java/base/DataValues.java",
        "tests/java/base/ClassPoolEntry.java",
        "tests/java/base/DataKeySet.java",
        "tests/java/base/Pair.java",
        "tests/java/base/MethodData.java",
        "tests/java/base/AnnotationInvocationHandler.java",
        "tests/java/base/VMClass.java",
        "tests/java/base/ConstantPool.java",
        "tests/java/base/Utf8PoolEntry.java",
        "tests/java/base/FieldRefPoolEntry.java",
        "tests/java/base/InterfaceMethodRefPoolEntry.java",
        "tests/java/base/Singleton.java",
        "tests/java/base/IntegerPoolEntry.java",
        "tests/java/base/PoolEntry.java",
        "tests/java/base/Data.java",
        "tests/java/base/Utf8.java",
        "tests/java/base/SystemClassLoader.java",
        "tests/java/base/VMField.java",
        "tests/java/base/Stream.java",
        "tests/java/base/ClassAddendum.java",
        "tests/java/base/Callback.java",
        "tests/java/base/Assembler.java",
        "tests/java/base/InnerClassReference.java",
        "tests/java/base/StringPoolEntry.java",
        "tests/java/base/Classes.java",
        "tests/java/base/FieldAddendum.java",
        "tests/java/base/Atomic.java",
        "tests/java/base/Code.java",
        "tests/java/base/Addendum.java",
        "tests/java/base/DataValueIterator.java",
        "tests/java/base/Function.java",
        "tests/java/base/Cell.java",
        "tests/java/base/DataEntryMap.java",
    ];

    // Apply filter_file if specified (single file filter)
    let mut filtered_files = if let Some(ref filter_file_name) = filter_file {
        file_list.into_iter()
            .filter(|file_path| {
                let path = Path::new(file_path);
                let file_name = path.file_name().unwrap().to_string_lossy();
                file_name == *filter_file_name
            })
            .collect()
    } else {
        file_list
    };
    
    // Apply general filter if specified
    if let Some(f) = &filter {
        filtered_files.retain(|file_path| file_path.contains(f));
    }
    
    // Calculate segment boundaries
    let total_files = filtered_files.len();
    let start_idx = segment_number * segment_size;
    
    // Check if segment is out of bounds
    if start_idx >= total_files {
        eprintln!("[CONFIG] Total files: {}, Segment {} is out of bounds (start_idx: {})", 
                  total_files, segment_number, start_idx);
        return;
    }
    
    let end_idx = std::cmp::min(start_idx + segment_size, total_files);
    
    eprintln!("[CONFIG] Total files: {}, Processing segment {}-{} ({} files)", 
              total_files, start_idx, end_idx - 1, end_idx - start_idx);
    
    // Skip to our segment
    let segment_files = filtered_files.into_iter()
        .skip(start_idx)
        .take(end_idx - start_idx)
        .take(max_files);

    for file_path in segment_files {
        let path = Path::new(&file_path);

        // Check if file exists
        if !path.exists() {
            eprintln!("[SKIP] File does not exist: {}", file_path);
            skipped += 1;
            continue;
        }

        // Check timeout
        if processed > 0 && processed % 5 == 0 {
            eprintln!("[PROGRESS] Processed: {}, Compared: {}, Skipped: {}", processed, compared, skipped);
        }

        // Read source
        let file_name = path.file_stem().unwrap().to_string_lossy().to_string();
        let source = match fs::read_to_string(path) {
            Ok(s) => s,
            Err(e) => { 
                let error_msg = format!("IO error reading source: {}", e);
                eprintln!("[ERROR] {}: {}", file_path, error_msg);
                bytecode_mismatches.push((path.display().to_string(), error_msg)); 
                break; // Stop on first error
            }
        };

        // Parse + review
        let ast = match parse_and_verify(&source) {
            Ok(a) => a,
            Err(e) => {
                let error_msg = format!("parse error: {}", e);
                eprintln!("[ERROR] {}: {}", file_path, error_msg);
                bytecode_mismatches.push((path.display().to_string(), error_msg));
                break; // Stop on first error
            }
        };

        // Determine package name and reference class path
        let package_name_opt = ast.package_decl.as_ref().map(|p| p.name.clone());
        let pkg_path_full = package_name_opt.as_deref().map(|p| p.replace('.', "/")).unwrap_or_else(|| "".to_string());
        let ref_pkg_sub = if let Some(pkg) = &package_name_opt { 
            if let Some(rest) = pkg.strip_prefix("java.") { 
                rest.replace('.', "/") 
            } else { 
                pkg.replace('.', "/") 
            } 
        } else { 
            String::new() 
        };
        let ref_class_path = if ref_pkg_sub.is_empty() { 
            ref_root.join(format!("{}.class", file_name)) 
        } else { 
            ref_root.join(&ref_pkg_sub).join(format!("{}.class", file_name)) 
        };
        
        if !ref_class_path.exists() { 
            eprintln!("[SKIP] No ref class: {}", ref_class_path.display()); 
            skipped += 1;
            continue; 
        }

        // Find matching top-level type by file name
        let type_decl_opt = ast.type_decls.iter().find(|td| match td { 
            TypeDecl::Class(c) => c.name == file_name, 
            TypeDecl::Interface(i) => i.name == file_name, 
            TypeDecl::Enum(e) => e.name == file_name, 
            TypeDecl::Annotation(a) => a.name == file_name 
        });
        let type_decl = match type_decl_opt { 
            Some(t) => t, 
            None => { 
                let error_msg = "no matching top-level type for file name".to_string();
                eprintln!("[ERROR] {}: {}", file_path, error_msg);
                bytecode_mismatches.push((path.display().to_string(), error_msg)); 
                break; // Stop on first error
            } 
        };

        // Generate class with TOLC (compilation is already successful at this point)
        let mut cw = ClassWriter::new();
        cw.set_package_name(package_name_opt.as_deref());
        cw.set_debug(true);
        cw.set_all_types(ast.type_decls.clone());
        let gen_res = match type_decl {
            TypeDecl::Class(c) => cw.generate_class(c),
            TypeDecl::Interface(i) => cw.generate_interface(i),
            TypeDecl::Enum(e) => cw.generate_enum(e),
            TypeDecl::Annotation(a) => cw.generate_annotation(a),
        };
        if let Err(e) = gen_res { 
            let error_msg = format!("codegen error: {}", e);
            eprintln!("[ERROR] {}: {}", file_path, error_msg);
            bytecode_mismatches.push((path.display().to_string(), error_msg)); 
            break; // Stop on first error
        }
        let class_file = cw.get_class_file();
        let class_bytes = class_file_to_bytes(&class_file);

        // Write our class to temp dir (package layout)
        let out_pkg_dir = if pkg_path_full.is_empty() { out_dir.clone() } else { out_dir.join(&pkg_path_full) };
        let _ = fs::create_dir_all(&out_pkg_dir);
        let our_class_path = out_pkg_dir.join(format!("{}.class", file_name));
        if let Err(e) = fs::write(&our_class_path, &class_bytes) { 
            let error_msg = format!("IO error writing our class: {}", e);
            eprintln!("[ERROR] {}: {}", file_path, error_msg);
            bytecode_mismatches.push((path.display().to_string(), error_msg)); 
            break; // Stop on first error
        }

        // Run javap on both TOLC and javac outputs to compare bytecode patterns
        // This is the core of our bytecode alignment test - we're not testing compilation
        let run_javap = |p: &Path| -> Result<String, String> {
            let out = std::process::Command::new("javap").arg("-c").arg("-verbose").arg(p).output().map_err(|e| format!("spawn javap failed: {}", e))?;
            if !out.status.success() { return Err(String::from_utf8_lossy(&out.stderr).to_string()); }
            let s = String::from_utf8_lossy(&out.stdout);
            let start = ["public class", "public abstract class", "public interface", "class "]
                .iter()
                .filter_map(|pat| s.find(pat))
                .min()
                .unwrap_or(0);
            let mut s = s[start..].replace("\r\n", "\n");
            s = strip_constant_pool(&s);
            s = strip_debug_tables(&s);
            s = strip_signatures_and_header_generics(&s);
            s = normalize_cp_indices(&s);
            s = normalize_field_references(&s);
            s = collapse_spaces(&s);
            Ok(s)
        };

        // Check for inner class files
        let ref_dir = ref_class_path.parent().unwrap();
        let inner_class_pattern = format!("{}$", file_name);
        let mut inner_class_files = Vec::new();
        
        if let Ok(entries) = fs::read_dir(ref_dir) {
            for entry in entries.flatten() {
                let entry_name = entry.file_name().to_string_lossy().to_string();
                if entry_name.starts_with(&inner_class_pattern) && entry_name.ends_with(".class") {
                    inner_class_files.push(entry_name);
                }
            }
        }
        
        // If there are inner class files, report them for now
        if !inner_class_files.is_empty() {
            eprintln!("[INFO] {} has inner classes: {:?}", file_name, inner_class_files);
            // For now, we'll still compare the main class file, but note the inner classes
        }

        match (run_javap(&our_class_path), run_javap(&ref_class_path)) {
            (Ok(a), Ok(b)) => {
                if !compare_javap_outputs(&a, &b) {
                    let error_msg = format!("javap mismatch - TOLC bytecode differs from javac reference\n--- TOLC generated ---\n{}\n--- javac reference ---\n{}", a, b);
                    eprintln!("[BYTECODE MISMATCH] {}: TOLC generated bytecode differs from javac reference", file_path);
                    bytecode_mismatches.push((path.display().to_string(), error_msg));
                    break; // Stop on first mismatch to focus on one alignment issue at a time
                } else {
                    compared += 1;
                }
            }
            (Err(e), _) => { 
                let error_msg = format!("javap error: {}", e);
                eprintln!("[ERROR] {}: {}", our_class_path.display(), error_msg);
                bytecode_mismatches.push((our_class_path.display().to_string(), error_msg)); 
                break; // Stop on first error
            }
            (_, Err(e)) => { 
                let error_msg = format!("javap error: {}", e);
                eprintln!("[ERROR] {}: {}", ref_class_path.display(), error_msg);
                bytecode_mismatches.push((ref_class_path.display().to_string(), error_msg)); 
                break; // Stop on first error
            }
        }
        
        processed += 1;
    }

    eprintln!("[SUMMARY] Segment {}/{} complete. Processed: {}, Compared: {}, Skipped: {}, Bytecode mismatches: {}", 
              segment_number, (total_files + segment_size - 1) / segment_size, processed, compared, skipped, bytecode_mismatches.len());

    if !bytecode_mismatches.is_empty() {
        eprintln!("First javap mismatch detected:");
        for (p, e) in &bytecode_mismatches { 
            eprintln!("- {} -> {}", p, e); 
            break; // Only show first failure
        }
        // NOTE: This is NOT a compilation failure! 
        // TOLC successfully compiled the Java source to bytecode.
        // The failure is that the generated bytecode differs from javac's reference output.
        // This means we need to align TOLC's bytecode generation with javac's patterns.
        panic!("Bytecode alignment needed: {} - TOLC compiled successfully but generated bytecode differs from javac reference", bytecode_mismatches[0].0);
    } else {
        eprintln!("Success! Segment {} completed with {} files processed, {} compared, {} skipped.", 
                  segment_number, processed, compared, skipped);
    }
}

fn strip_constant_pool(s: &str) -> String {
    let mut out = Vec::new();
    let mut in_cp = false;
    for line in s.lines() {
        if !in_cp && line.trim_start().starts_with("Constant pool:") { in_cp = true; continue; }
        if in_cp {
            if line.trim().is_empty() { in_cp = false; continue; }
            if line.trim_start().starts_with('#') { continue; }
            if line.trim_start().starts_with('{') { in_cp = false; out.push(line); continue; }
            continue;
        }
        out.push(line);
    }
    out.join("\n")
}

fn strip_debug_tables(s: &str) -> String {
    let mut out = Vec::new();
    let mut skip = false;
    for line in s.lines() {
        let trimmed = line.trim_start();
        if !skip && (trimmed.starts_with("LineNumberTable:") || trimmed.starts_with("LocalVariableTable:")) {
            skip = true;
            continue;
        }
        if skip {
            if trimmed.is_empty() {
                skip = false;
                continue;
            }
            if trimmed.starts_with("public ") || trimmed.starts_with("}") || trimmed.starts_with("Code:") || trimmed.starts_with("descriptor:") || trimmed.starts_with("flags:") {
                skip = false;
                out.push(line);
                continue;
            }
            continue;
        }
        out.push(line);
    }
    out.join("\n")
}

fn strip_signatures_and_header_generics(s: &str) -> String {
    let mut out = Vec::new();
    for line in s.lines() {
        // Simplified: just keep all lines as-is
        // This avoids complex parsing that might introduce bugs
        out.push(line.to_string());
    }
    out.join("\n")
}

fn normalize_cp_indices(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    let mut it = s.chars().peekable();
    while let Some(ch) = it.next() {
        if ch == '#' {
            let mut saw_digit = false;
            while let Some(&next) = it.peek() {
                if next.is_ascii_digit() { saw_digit = true; it.next(); } else { break; }
            }
            if saw_digit { out.push_str("#X"); } else { out.push('#'); }
        } else {
            out.push(ch);
        }
    }
    out
}

fn normalize_field_references(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    for line in s.lines() {
        if let Some(field_start) = line.find("// Field ") {
            let prefix = &line[..field_start];
            let field_part = &line[field_start + 9..]; // Skip "// Field "
            
            // Look for pattern: ClassName.fieldName:descriptor
            if let Some(dot_pos) = field_part.find('.') {
                if let Some(colon_pos) = field_part.find(':') {
                    if dot_pos < colon_pos {
                        // Extract fieldName:descriptor part
                        let field_name_and_desc = &field_part[dot_pos + 1..];
                        result.push_str(prefix);
                        result.push_str("// Field ");
                        result.push_str(field_name_and_desc);
                        result.push('\n');
                        continue;
                    }
                }
            }
        }
        result.push_str(line);
        result.push('\n');
    }
    
    // Remove the trailing newline
    if result.ends_with('\n') {
        result.pop();
    }
    result
}

fn collapse_spaces(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    let mut prev_space = false;
    for ch in s.chars() {
        if ch == '\r' { continue; }
        let is_space = ch == ' ' || ch == '\t';
        if is_space {
            if !prev_space { out.push(' '); }
            prev_space = true;
        } else {
            out.push(ch);
            prev_space = false;
        }
    }
    out
        .lines()
        .map(|l| l.trim_end())
        .collect::<Vec<_>>()
        .join("\n")
}

fn classes_root() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("tests").join("classes").join("java")
}

/// Compare javap outputs line by line, ignoring attribute order differences
/// JVM doesn't care about the order of attributes, so we normalize them
fn compare_javap_outputs(ours: &str, reference: &str) -> bool {
    let our_lines: Vec<&str> = ours.lines().collect();
    let ref_lines: Vec<&str> = reference.lines().collect();
    
    // Quick check: if line counts are very different, they're probably not the same
    if (our_lines.len() as i32 - ref_lines.len() as i32).abs() > 2 {
        return false;
    }
    
    // Normalize both outputs by sorting attributes within their sections
    let normalized_ours = normalize_javap_output(&our_lines);
    let normalized_ref = normalize_javap_output(&ref_lines);
    
    // Compare normalized outputs
    normalized_ours == normalized_ref
}

/// Normalize javap output by sorting attributes within their sections
/// This handles cases where JVM attribute order might differ
fn normalize_javap_output(lines: &[&str]) -> Vec<String> {
    let mut result = Vec::new();
    let mut current_section = Vec::new();
    let mut _in_method = false;
    let mut _in_interface = false;
    
    for &line in lines {
        let trimmed = line.trim();
        
        // Detect section boundaries
        if trimmed.starts_with("public ") && (trimmed.contains("class") || trimmed.contains("interface")) {
            // Class/interface declaration - flush current section and start new
            if !current_section.is_empty() {
                result.extend(sort_section_attributes(&current_section));
                current_section.clear();
            }
            _in_interface = trimmed.contains("interface");
            result.push(line.to_string());
            continue;
        }
        
        if trimmed.starts_with("public ") && trimmed.contains("(") && !trimmed.contains("class") && !trimmed.contains("interface") {
            // Method declaration - flush current section and start new
            if !current_section.is_empty() {
                result.extend(sort_section_attributes(&current_section));
                current_section.clear();
            }
            _in_method = true;
            result.push(line.to_string());
            continue;
        }
        
        if trimmed == "}" {
            // End of section - flush current section
            if !current_section.is_empty() {
                result.extend(sort_section_attributes(&current_section));
                current_section.clear();
            }
            _in_method = false;
            result.push(line.to_string());
            continue;
        }
        
        // Collect lines in current section
        current_section.push(line.to_string());
    }
    
    // Flush any remaining section
    if !current_section.is_empty() {
        result.extend(sort_section_attributes(&current_section));
    }
    
    result
}

/// Sort attributes within a section to normalize order
fn sort_section_attributes(lines: &[String]) -> Vec<String> {
    let mut result = Vec::new();
    let mut attributes = Vec::new();
    let mut other_lines = Vec::new();
    
    for line in lines {
        let trimmed = line.trim();
        
        // Identify attribute lines
        if trimmed.starts_with("descriptor:") || 
           trimmed.starts_with("flags:") || 
           trimmed.starts_with("Signature:") || 
           trimmed.starts_with("Exceptions:") ||
           trimmed.starts_with("SourceFile:") ||
           trimmed.starts_with("Code:") ||
           trimmed.starts_with("LineNumberTable:") ||
           trimmed.starts_with("LocalVariableTable:") ||
           trimmed.starts_with("InnerClasses:") ||
           trimmed.starts_with("RuntimeVisibleAnnotations:") ||
           trimmed.starts_with("RuntimeInvisibleAnnotations:") ||
           trimmed.starts_with("RuntimeVisibleParameterAnnotations:") ||
           trimmed.starts_with("RuntimeInvisibleParameterAnnotations:") ||
           trimmed.starts_with("AnnotationDefault:") ||
           trimmed.starts_with("Synthetic:") ||
           trimmed.starts_with("Deprecated:") ||
           trimmed.starts_with("EnclosingMethod:") ||
           trimmed.starts_with("BootstrapMethods:") ||
           trimmed.starts_with("MethodParameters:") ||
           trimmed.starts_with("Module:") ||
           trimmed.starts_with("ModulePackages:") ||
           trimmed.starts_with("ModuleMainClass:") ||
           trimmed.starts_with("NestHost:") ||
           trimmed.starts_with("NestMembers:") ||
           trimmed.starts_with("PermittedSubclasses:") ||
           trimmed.starts_with("Record:") ||
           trimmed.starts_with("throws ") {
            attributes.push(line.clone());
        } else {
            other_lines.push(line.clone());
        }
    }
    
    // Sort attributes for consistent ordering
    attributes.sort();
    
    // Add other lines first, then sorted attributes
    result.extend(other_lines);
    result.extend(attributes);
    
    result
}
