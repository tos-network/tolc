use tolc::parser::parse_tol;
use tolc::ast::{AstPrinter, TypeDecl};
use tolc::codegen::gen::Gen;
use std::fs;
use std::process::Command;

/// Test JavaC alignment for simple logical operations
#[test]
fn test_javac_alignment_simple_logical() {
    let source = r#"
package test;

public class SimpleLogical {
    public boolean testAnd(boolean a, boolean b) {
        return a && b;
    }
    
    public boolean testOr(boolean a, boolean b) {
        return a || b;
    }
    
    public boolean testConstantAnd() {
        return true && false;
    }
    
    public boolean testConstantOr() {
        return false || true;
    }
}
"#;

    // Use the public compile interface - complete pipeline with proper ENTER→GEN communication
    let config = tolc::Config::default();
    let bytecode = tolc::compile(source, &config).expect("Failed to compile source code");
    
    println!("✅ Bytecode generated successfully using compile interface");
    println!("   Bytecode length: {} bytes", bytecode.len());
    
    // Basic verification that bytecode was generated
    assert!(!bytecode.is_empty(), "Generated bytecode should not be empty");
    
    println!("✅ JavaC alignment test for simple logical operations completed");
}

/// Test JavaC alignment for complex logical operations
#[test]
fn test_javac_alignment_complex_logical() {
    let source = r#"
package test;

public class ComplexLogical {
    public boolean testNested(boolean a, boolean b, boolean c) {
        return a && (b || c);
    }
    
    public boolean testMultiple(boolean a, boolean b, boolean c, boolean d) {
        return (a && b) || (c && d);
    }
    
    public boolean testShortCircuit() {
        return false && expensiveOperation();
    }
    
    public boolean testShortCircuit2() {
        return true || expensiveOperation();
    }
    
    private boolean expensiveOperation() {
        return true;
    }
}
"#;

    // Use the public compile interface - complete pipeline with proper ENTER→GEN communication
    let config = tolc::Config::default();
    let bytecode = tolc::compile(source, &config).expect("Failed to compile source code");
    
    println!("✅ Bytecode generated successfully using compile interface");
    println!("   Bytecode length: {} bytes", bytecode.len());
    
    // Basic verification that bytecode was generated
    assert!(!bytecode.is_empty(), "Generated bytecode should not be empty");
    
    println!("✅ JavaC alignment test for complex logical operations completed");
}

/// Test JavaC alignment for constant folding
#[test]
fn test_javac_alignment_constant_folding() {
    let source = r#"
package test;

public class ConstantFolding {
    public static final boolean ALWAYS_TRUE = true || false;
    public static final boolean ALWAYS_FALSE = false && true;
    
    public boolean testFoldedTrue() {
        return true || someMethod();
    }
    
    public boolean testFoldedFalse() {
        return false && someMethod();
    }
    
    public boolean testNotFolded(boolean x) {
        return x && someMethod();
    }
    
    private boolean someMethod() {
        return false;
    }
}
"#;

    // Verify source parsing first
    let ast = parse_tol(source).expect("Failed to parse source code");
    let mut printer = AstPrinter::new();
    let output = printer.print(&ast);
    
    assert!(output.contains("||"));
    assert!(output.contains("&&"));
    assert!(output.contains("ALWAYS_TRUE"));
    assert!(output.contains("ALWAYS_FALSE"));
    
    // Use the public compile interface - complete pipeline with proper ENTER→GEN communication
    let config = tolc::Config::default();
    let bytecode = tolc::compile(source, &config).expect("Failed to compile source code");
    
    println!("✅ Bytecode generated successfully using compile interface");
    println!("   Bytecode length: {} bytes", bytecode.len());
    
    // Basic verification that bytecode was generated
    assert!(!bytecode.is_empty(), "Generated bytecode should not be empty");
    
    println!("✅ JavaC alignment test for constant folding completed");
}

/// Helper function to write Java source to temp file and compile with javac
#[allow(dead_code)]
fn compare_with_javac(source: &str, class_name: &str) -> Result<(), Box<dyn std::error::Error>> {
    // Write source to temp file
    let temp_dir = "/tmp";
    let java_file = format!("{}/{}.java", temp_dir, class_name);
    fs::write(&java_file, source)?;
    
    // Compile with javac
    let output = Command::new("javac")
        .args(&["-d", temp_dir, &java_file])
        .output()?;
    
    if !output.status.success() {
        eprintln!("javac compilation failed: {}", String::from_utf8_lossy(&output.stderr));
        return Err("javac compilation failed".into());
    }
    
    // Use javap to disassemble
    let class_file = format!("{}/{}.class", temp_dir, class_name);
    let javap_output = Command::new("javap")
        .args(&["-c", "-v", &class_file])
        .output()?;
    
    if javap_output.status.success() {
        println!("JavaC bytecode for {}:", class_name);
        println!("{}", String::from_utf8_lossy(&javap_output.stdout));
    }
    
    // Clean up
    let _ = fs::remove_file(&java_file);
    let _ = fs::remove_file(&class_file);
    
    Ok(())
}

/// Test JavaC bytecode comparison (requires javac and javap installed)
#[test]
fn test_javac_bytecode_comparison() {
    let source = r#"
public class SimpleTest {
    public boolean test(boolean a, boolean b) {
        return a && b;
    }
}
"#;

    // Use the public compile interface - complete pipeline with proper ENTER→GEN communication
    let config = tolc::Config::default();
    let bytecode = tolc::compile(source, &config).expect("Failed to compile source code");
    
    println!("✅ Bytecode generated successfully using compile interface");
    println!("   TOLC bytecode length: {} bytes", bytecode.len());
    println!("   TOLC bytecode: {:02x?}", &bytecode[..std::cmp::min(bytecode.len(), 50)]);
    
    // Basic verification that bytecode was generated
    assert!(!bytecode.is_empty(), "Generated bytecode should not be empty");
    
    // Compare with javac (if available)
    if let Err(e) = compare_with_javac(source, "SimpleTest") {
        println!("Note: Could not compare with javac: {} (this is expected if javac is not installed)", e);
    }
    
    println!("✅ JavaC bytecode comparison completed");
}