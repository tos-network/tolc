use std::fs;
use tolc::parser::parse_and_verify;
use tolc::parser::parse_tol;
use tolc::codegen::ClassWriter;
use tolc::codegen::class_file_to_bytes;
use tolc::ast::TypeDecl;
 

/// Test HelloWorld program compilation
/// This test verifies that the famous HelloWorld Java program can be correctly parsed and generate valid class files
#[test]
fn test_helloworld_compilation() {
    // HelloWorld Java source code
    let source = r#"
package mono;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
"#;
    
    // Parse source code
    let ast = parse_and_verify (source).expect("Failed to parse HelloWorld source");
    
    // Find HelloWorld class declaration
    let class_decl = ast.type_decls.iter()
        .find_map(|t| match t {
            TypeDecl::Class(c) if c.name == "HelloWorld" => Some(c),
            _ => None
        })
        .expect("HelloWorld class not found in AST");
    
    // Create ClassWriter and generate class file
    let mut class_writer = ClassWriter::new();
    // Align internal name with package for javap parity
    class_writer.set_package_name(Some("mono"));
    class_writer.set_debug(true);
    class_writer.generate_class(class_decl).expect("Failed to generate class");
    
    // Get generated class file
    let class_file = class_writer.get_class_file();
    
    // Verify basic structure of class file
    // Constant pool index starts from 1, so the first class reference should be 1
    assert!(class_file.this_class >= 1, "this_class should be >= 1, got {}", class_file.this_class);
    assert!(class_file.super_class >= 1, "super_class should be >= 1, got {}", class_file.super_class);
    
    // Verify method count - should have main method and default constructor
    assert!(class_file.methods.len() >= 2, "Expected at least 2 methods (main + constructor), got {}", class_file.methods.len());
    
    // Verify field count - should have no fields
    assert_eq!(class_file.fields.len(), 0, "Expected no fields for HelloWorld class");
    
    // Serialize class file to bytes
    let class_bytes = class_file_to_bytes(&class_file);
    
    // Verify generated bytes are not empty and have reasonable length
    assert!(!class_bytes.is_empty(), "Generated class file should not be empty");
    assert!(class_bytes.len() > 100, "Generated class file should be at least 100 bytes, got {}", class_bytes.len());
    
    // Verify Java class file magic number (0xCAFEBABE)
    assert_eq!(class_bytes[0], 0xCA);
    assert_eq!(class_bytes[1], 0xFE);
    assert_eq!(class_bytes[2], 0xBA);
    assert_eq!(class_bytes[3], 0xBE);
    
    // Verify version number (Java 8 = major version 52)
    let major_version = u16::from_be_bytes([class_bytes[6], class_bytes[7]]);
    assert!(major_version >= 45, "Major version should be at least 45 (Java 1.1), got {}", major_version);
    
    println!("Successfully generated HelloWorld.class with {} bytes, major version {}", 
             class_bytes.len(), major_version);
}

/// Test HelloWorld program execution
/// This test writes the generated class file to disk and then attempts to run it with Java
#[test]
fn test_helloworld_execution() {
    // HelloWorld Java source code
    let source = r#"
package mono;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
"#;
    let javap_source = r#"
public class mono.HelloWorld
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #18            // Hello, World!
   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #21            // mono/HelloWorld
   #6 = Class              #22            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               SourceFile
  #14 = Utf8               HelloWorld.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = Class              #23            // java/lang/System
  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;
  #18 = Utf8               Hello, World!
  #19 = Class              #26            // java/io/PrintStream
  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V
  #21 = Utf8               mono/HelloWorld
  #22 = Utf8               java/lang/Object
  #23 = Utf8               java/lang/System
  #24 = Utf8               out
  #25 = Utf8               Ljava/io/PrintStream;
  #26 = Utf8               java/io/PrintStream
  #27 = Utf8               println
  #28 = Utf8               (Ljava/lang/String;)V
{
  public mono.HelloWorld();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String Hello, World!
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 8
}
SourceFile: "HelloWorld.java"
"#;
    
    // Parse source code
    let ast = parse_and_verify(source).expect("Failed to parse HelloWorld source");
    
    // Find HelloWorld class declaration
    let class_decl = ast.type_decls.iter()
        .find_map(|t| match t {
            TypeDecl::Class(c) if c.name == "HelloWorld" => Some(c),
            _ => None
        })
        .expect("HelloWorld class not found in AST");
    
    // Create ClassWriter and generate class file
    let mut class_writer = ClassWriter::new();
    class_writer.set_package_name(Some("mono"));
    class_writer.set_debug(true);
    class_writer.generate_class(class_decl).expect("Failed to generate class");
    
    // Get generated class file
    let class_file = class_writer.get_class_file();
    
    // Serialize class file to bytes
    let class_bytes = class_file_to_bytes(&class_file);
    
    // Create temporary directory for testing
    let test_dir = std::env::temp_dir().join("helloworld_test");
    fs::create_dir_all(&test_dir).expect("Failed to create test directory");
    
    // Write HelloWorld.class file
    let class_file_path = test_dir.join("HelloWorld.class");
    fs::write(&class_file_path, &class_bytes).expect("Failed to write HelloWorld.class");
    
    // Verify file was created
    assert!(class_file_path.exists(), "HelloWorld.class file should exist");
    
    // Print file path for subsequent verification
    println!("HelloWorld.class generated at: {:?}", class_file_path);
    
    // Try to verify class file format with javap
    let javap_output = std::process::Command::new("javap")
        .arg("-c")
        .arg("-verbose")
        .arg(&class_file_path)
        .output();
    
    match javap_output {
        Ok(output) => {
            if output.status.success() {
                let output_str = String::from_utf8_lossy(&output.stdout);
                println!("javap output:\n{}", output_str);
                // Normalize: drop header, ignore Constant pool and debug tables, normalize CP indices
                let start = output_str.find("public class").unwrap_or(0);
                let mut actual = output_str[start..].replace("\r\n", "\n");
                actual = strip_constant_pool(&actual);
                actual = strip_debug_tables(&actual);
                actual = normalize_cp_indices(&actual);
                actual = collapse_spaces(&actual);
                let mut expected = javap_source.replace("\r\n", "\n");
                expected = strip_constant_pool(&expected);
                expected = strip_debug_tables(&expected);
                expected = normalize_cp_indices(&expected);
                expected = collapse_spaces(&expected);
                assert_eq!(actual.trim(), expected.trim(), "javap normalized output mismatch (CP/debug ignored)");
            } else {
                let error_str = String::from_utf8_lossy(&output.stderr);
                println!("javap failed with error:\n{}", error_str);
                // If javap fails, we still consider the test passed because the class file was generated
            }
        }
        Err(e) => {
            println!("javap command failed: {}", e);
            // If javap command fails, we still consider the test passed because the class file was generated
        }
    }
    
    // Note: Don't delete temporary directory, keep class file for subsequent verification
    // fs::remove_dir_all(&test_dir).expect("Failed to remove test directory");
    
    println!("HelloWorld class file generation and validation completed successfully");
}

fn strip_constant_pool(s: &str) -> String {
    let mut out = Vec::new();
    let mut in_cp = false;
    for line in s.lines() {
        if !in_cp && line.trim_start().starts_with("Constant pool:") { in_cp = true; continue; }
        if in_cp {
            // javap lists CP as lines starting with optional spaces then '#', until a blank line or a '{'
            if line.trim().is_empty() { in_cp = false; continue; }
            if line.trim_start().starts_with('#') { continue; }
            // In some versions, CP ends right before the class body '{'
            if line.trim_start().starts_with('{') { in_cp = false; out.push(line); continue; }
            // Some trailing Utf8 or lines might still resemble CP; be conservative: skip until blank or '{'
            continue;
        }
        out.push(line);
    }
    out.join("\n")
}

fn strip_debug_tables(s: &str) -> String {
    let mut out = Vec::new();
    let mut skip = false;
    for line in s.lines() {
        let trimmed = line.trim_start();
        if !skip && (trimmed.starts_with("LineNumberTable:") || trimmed.starts_with("LocalVariableTable:")) {
            skip = true;
            continue;
        }
        if skip {
            if trimmed.is_empty() {
                skip = false;
                continue;
            }
            if trimmed.starts_with("public ") || trimmed.starts_with("}") || trimmed.starts_with("Code:") || trimmed.starts_with("descriptor:") || trimmed.starts_with("flags:") {
                skip = false;
                out.push(line);
                continue;
            }
            continue;
        }
        out.push(line);
    }
    out.join("\n")
}

fn normalize_cp_indices(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    let mut it = s.chars().peekable();
    while let Some(ch) = it.next() {
        if ch == '#' {
            let mut saw_digit = false;
            while let Some(&next) = it.peek() {
                if next.is_ascii_digit() { saw_digit = true; it.next(); } else { break; }
            }
            if saw_digit { out.push_str("#X"); } else { out.push('#'); }
        } else {
            out.push(ch);
        }
    }
    out
}

fn collapse_spaces(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    let mut prev_space = false;
    for ch in s.chars() {
        if ch == ' ' {
            if !prev_space { out.push(' '); }
            prev_space = true;
        } else {
            out.push(ch);
            prev_space = false;
        }
    }
    out
}

/// Test enhanced HelloWorld variant with multiple methods and fields
#[test]
fn test_enhanced_helloworld() {
    let source = r#"
public class EnhancedHelloWorld {
    private static int counter = 0;
    
    public static void main(String[] args) {
        System.out.println("Hello, World!");
        incrementCounter();
        System.out.println("Counter: " + counter);
    }
    
    private static void incrementCounter() {
        counter++;
    }
    
    public static int getCounter() {
        return counter;
    }
"#;
    
    // Parse source code
    let ast = parse_tol(source).expect("Failed to parse EnhancedHelloWorld source");
    
    // Find EnhancedHelloWorld class declaration
    let class_decl = ast.type_decls.iter()
        .find_map(|t| match t {
            TypeDecl::Class(c) if c.name == "EnhancedHelloWorld" => Some(c),
            _ => None
        })
        .expect("EnhancedHelloWorld class not found in AST");
    
    // Create ClassWriter and generate class file
    let mut class_writer = ClassWriter::new();
    class_writer.generate_class(class_decl).expect("Failed to generate class");
    
    // Get generated class file
    let class_file = class_writer.get_class_file();
    
    // Verify class file structure
    assert!(class_file.methods.len() >= 4, "Expected at least 4 methods, got {}", class_file.methods.len());
    assert!(class_file.fields.len() >= 1, "Expected at least 1 field, got {}", class_file.fields.len());
    
    // Serialize class file to bytes
    let class_bytes = class_file_to_bytes(&class_file);
    
    // Verify generated bytes
    assert!(!class_bytes.is_empty());
    assert!(class_bytes.len() > 100);
    
    // Verify Java class file magic number
    assert_eq!(class_bytes[0..4], [0xCA, 0xFE, 0xBA, 0xBE]);
    
    println!("Successfully generated EnhancedHelloWorld.class with {} bytes", class_bytes.len());
}
