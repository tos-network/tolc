use std::fs;
use tolc::parser::parse_and_verify;
use tolc::parser::parse_tol;
use tolc::codegen::ClassWriter;
use tolc::codegen::class_file_to_bytes;
use tolc::ast::{TypeDecl, ClassMember};
 

/// Test HelloWorld program compilation
/// This test verifies that the famous HelloWorld Java program can be correctly parsed and generate valid class files
#[test]
fn test_helloworld_compilation() {
    println!("ðŸš€ DEBUG: Starting test_helloworld_compilation test...");
    
    // HelloWorld Java source code
    let source = r#"
package mono;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
"#;
    
    println!("ðŸ” DEBUG: HelloWorld source code prepared");
    
    // Parse source code
    println!("ðŸ” DEBUG: About to parse source code...");
    let ast = parse_and_verify (source).expect("Failed to parse HelloWorld source");
    println!("ðŸ” DEBUG: Source code parsed successfully");
    println!("ðŸ” DEBUG: AST has {} type declarations", ast.type_decls.len());
    
    // Find HelloWorld class declaration
    println!("ðŸ” DEBUG: Looking for HelloWorld class in AST...");
    let class_decl = ast.type_decls.iter()
        .find_map(|t| match t {
            TypeDecl::Class(c) if c.name == "HelloWorld" => Some(c),
            _ => None
        })
        .expect("HelloWorld class not found in AST");
    println!("ðŸ” DEBUG: HelloWorld class found in AST");
    
    // Create ClassWriter and generate class file
    println!("ðŸ” DEBUG: Creating ClassWriter...");
    let mut class_writer = ClassWriter::new();
    println!("ðŸ” DEBUG: ClassWriter created successfully");
    
    // Align internal name with package for javap parity
    println!("ðŸ” DEBUG: Setting package name to 'mono'...");
    class_writer.set_package_name(Some("mono"));
    println!("ðŸ” DEBUG: Package name set successfully");
    
    println!("ðŸ” DEBUG: Setting debug mode...");
    class_writer.set_debug(true);
    println!("ðŸ” DEBUG: Debug mode set successfully");
    
    println!("ðŸ” DEBUG: About to call generate_class()...");
    println!("ðŸ” DEBUG: Class declaration has {} body members", class_decl.body.len());
    
    // Count methods and fields
    let method_count = class_decl.body.iter()
        .filter(|m| matches!(m, tolc::ast::ClassMember::Method(_)))
        .count();
    let field_count = class_decl.body.iter()
        .filter(|m| matches!(m, tolc::ast::ClassMember::Field(_)))
        .count();
    let constructor_count = class_decl.body.iter()
        .filter(|m| matches!(m, tolc::ast::ClassMember::Constructor(_)))
        .count();
    
    println!("ðŸ” DEBUG: Class has {} methods, {} fields, {} constructors", method_count, field_count, constructor_count);
    
    let start_time = std::time::Instant::now();
    let result = class_writer.generate_class(class_decl);
    let duration = start_time.elapsed();
    
    match result {
        Ok(_) => {
            println!("âœ… DEBUG: generate_class() completed successfully in {:?}", duration);
        }
        Err(e) => {
            println!("âŒ DEBUG: generate_class() failed after {:?}: {}", duration, e);
            panic!("Failed to generate class: {}", e);
        }
    }
    
    println!("ðŸ” DEBUG: Getting generated class file...");
    // Get generated class file
    let class_file = class_writer.get_class_file();
    println!("ðŸ” DEBUG: Class file retrieved successfully");
    println!("ðŸ” DEBUG: Class file has {} methods", class_file.methods.len());
    println!("ðŸ” DEBUG: Class file has {} fields", class_file.fields.len());
    println!("ðŸ” DEBUG: Class file has {} attributes", class_file.attributes.len());
    
    // Verify basic structure of class file
    // Constant pool index starts from 1, so the first class reference should be 1
    assert!(class_file.this_class >= 1, "this_class should be >= 1, got {}", class_file.this_class);
    assert!(class_file.super_class >= 1, "super_class should be >= 1, got {}", class_file.super_class);
    
    // Verify method count - should have main method and default constructor
    assert!(class_file.methods.len() >= 2, "Expected at least 2 methods (main + constructor), got {}", class_file.methods.len());
    
    // Verify field count - should have no fields
    assert_eq!(class_file.fields.len(), 0, "Expected no fields for HelloWorld class");
    
    // Serialize class file to bytes
    let class_bytes = class_file_to_bytes(&class_file);
    
    // Verify generated bytes are not empty and have reasonable length
    assert!(!class_bytes.is_empty(), "Generated class file should not be empty");
    assert!(class_bytes.len() > 100, "Generated class file should be at least 100 bytes, got {}", class_bytes.len());
    
    // Verify Java class file magic number (0xCAFEBABE)
    assert_eq!(class_bytes[0], 0xCA);
    assert_eq!(class_bytes[1], 0xFE);
    assert_eq!(class_bytes[2], 0xBA);
    assert_eq!(class_bytes[3], 0xBE);
    
    // Verify version number (Java 8 = major version 52)
    let major_version = u16::from_be_bytes([class_bytes[6], class_bytes[7]]);
    assert!(major_version >= 45, "Major version should be at least 45 (Java 1.1), got {}", major_version);
    
    println!("Successfully generated HelloWorld.class with {} bytes, major version {}", 
             class_bytes.len(), major_version);
    
    println!("ðŸŽ‰ DEBUG: test_helloworld_compilation test completed successfully!");
}

/// Test HelloWorld program execution
/// This test writes the generated class file to disk and then attempts to run it with Java
#[test]
fn test_helloworld_execution() {
    // HelloWorld Java source code
    let source = r#"package mono;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
"#;

// javac -g tests/mono/HelloWorld.java
    let javap_source = r#"
public class mono.HelloWorld
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#20         // java/lang/Object."<init>":()V
   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #23            // Hello, World!
   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #26            // mono/HelloWorld
   #6 = Class              #27            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lmono/HelloWorld;
  #14 = Utf8               main
  #15 = Utf8               ([Ljava/lang/String;)V
  #16 = Utf8               args
  #17 = Utf8               [Ljava/lang/String;
  #18 = Utf8               SourceFile
  #19 = Utf8               HelloWorld.java
  #20 = NameAndType        #7:#8          // "<init>":()V
  #21 = Class              #28            // java/lang/System
  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;
  #23 = Utf8               Hello, World!
  #24 = Class              #31            // java/io/PrintStream
  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V
  #26 = Utf8               mono/HelloWorld
  #27 = Utf8               java/lang/Object
  #28 = Utf8               java/lang/System
  #29 = Utf8               out
  #30 = Utf8               Ljava/io/PrintStream;
  #31 = Utf8               java/io/PrintStream
  #32 = Utf8               println
  #33 = Utf8               (Ljava/lang/String;)V
{
  public mono.HelloWorld();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lmono/HelloWorld;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String Hello, World!
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
}
SourceFile: "HelloWorld.java"
"#;
    
    // Parse source code
    let ast = parse_and_verify(source).expect("Failed to parse HelloWorld source");
    
    // Find HelloWorld class declaration
    let class_decl = ast.type_decls.iter()
        .find_map(|t| match t {
            TypeDecl::Class(c) if c.name == "HelloWorld" => Some(c),
            _ => None
        })
        .expect("HelloWorld class not found in AST");
    
    // Create ClassWriter and generate class file
    let mut class_writer = ClassWriter::new();
    class_writer.set_package_name(Some("mono"));
    class_writer.set_debug(true);
    class_writer.generate_class(class_decl).expect("Failed to generate class");
    
    // Get generated class file
    let class_file = class_writer.get_class_file();
    
    // Serialize class file to bytes
    let class_bytes = class_file_to_bytes(&class_file);
    
    // Create temporary directory for testing
    let test_dir = std::env::temp_dir().join("helloworld_test");
    fs::create_dir_all(&test_dir).expect("Failed to create test directory");
    
    // Write HelloWorld.class file
    let class_file_path = test_dir.join("HelloWorld.class");
    fs::write(&class_file_path, &class_bytes).expect("Failed to write HelloWorld.class");
    
    // Verify file was created
    assert!(class_file_path.exists(), "HelloWorld.class file should exist");
    
    // Print file path for subsequent verification
    println!("HelloWorld.class generated at: {:?}", class_file_path);
    
    // Try to verify class file format with javap
    let javap_output = std::process::Command::new("javap")
        .arg("-c")
        .arg("-verbose")
        .arg(&class_file_path)
        .output();
    
    match javap_output {
        Ok(output) => {
            if output.status.success() {
                let output_str = String::from_utf8_lossy(&output.stdout);
                println!("javap output:\n{}", output_str);
                // Normalize: drop header, ignore Constant pool and debug tables, normalize CP indices
                let start = output_str.find("public class").unwrap_or(0);
                let mut actual = output_str[start..].replace("\r\n", "\n");
                actual = strip_constant_pool(&actual);
                actual = strip_debug_tables(&actual);
                actual = normalize_cp_indices(&actual);
                actual = collapse_spaces(&actual);
                let mut expected = javap_source.replace("\r\n", "\n");
                expected = strip_constant_pool(&expected);
                expected = strip_debug_tables(&expected);
                expected = normalize_cp_indices(&expected);
                expected = collapse_spaces(&expected);
                assert_eq!(actual.trim(), expected.trim(), "javap normalized output mismatch (CP/debug ignored)");
                // Also run strict JVM verifier and execute the class to ensure runtime correctness
                let mono_dir = test_dir.join("mono");
                fs::create_dir_all(&mono_dir).expect("Failed to create mono/ package directory");
                let class_in_pkg = mono_dir.join("HelloWorld.class");
                fs::copy(&class_file_path, &class_in_pkg).expect("Failed to place class into package dir");

                // Verify class format strictly
                let verify_out = std::process::Command::new("java")
                    .arg("-Xverify:all")
                    .arg("-cp")
                    .arg(&test_dir)
                    .arg("mono.HelloWorld")
                    .output();
                match verify_out {
                    Ok(vout) => {
                        if !vout.status.success() {
                            let err = String::from_utf8_lossy(&vout.stderr);
                            panic!("java -Xverify:all failed: {}", err);
                        }
                    }
                    Err(e) => panic!("failed to run java -Xverify:all: {}", e),
                }

                // Execute and check output
                let run_out = std::process::Command::new("java")
                    .arg("-cp")
                    .arg(&test_dir)
                    .arg("mono.HelloWorld")
                    .output();
                match run_out {
                    Ok(rout) => {
                        assert!(rout.status.success(), "java run failed: {}", String::from_utf8_lossy(&rout.stderr));
                        let stdout = String::from_utf8_lossy(&rout.stdout);
                        assert!(stdout.contains("Hello, World!"), "unexpected program output: {}", stdout);
                    }
                    Err(e) => panic!("failed to run java: {}", e),
                }
            } else {
                let error_str = String::from_utf8_lossy(&output.stderr);
                println!("javap failed with error:\n{}", error_str);
                // If javap fails, we still consider the test passed because the class file was generated
            }
        }
        Err(e) => {
            println!("javap command failed: {}", e);
            // If javap command fails, we still consider the test passed because the class file was generated
        }
    }
    
    // Note: Don't delete temporary directory, keep class file for subsequent verification
    // fs::remove_dir_all(&test_dir).expect("Failed to remove test directory");
    
    println!("HelloWorld class file generation and validation completed successfully");
}

fn strip_constant_pool(s: &str) -> String {
    let mut out = Vec::new();
    let mut in_cp = false;
    for line in s.lines() {
        if !in_cp && line.trim_start().starts_with("Constant pool:") { in_cp = true; continue; }
        if in_cp {
            // javap lists CP as lines starting with optional spaces then '#', until a blank line or a '{'
            if line.trim().is_empty() { in_cp = false; continue; }
            if line.trim_start().starts_with('#') { continue; }
            // In some versions, CP ends right before the class body '{'
            if line.trim_start().starts_with('{') { in_cp = false; out.push(line); continue; }
            // Some trailing Utf8 or lines might still resemble CP; be conservative: skip until blank or '{'
            continue;
        }
        out.push(line);
    }
    out.join("\n")
}

fn strip_debug_tables(s: &str) -> String {
    let mut out = Vec::new();
    let mut skip = false;
    for line in s.lines() {
        let trimmed = line.trim_start();
        if !skip && (trimmed.starts_with("LineNumberTable:") || trimmed.starts_with("LocalVariableTable:")) {
            skip = true;
            continue;
        }
        if skip {
            if trimmed.is_empty() {
                skip = false;
                continue;
            }
            if trimmed.starts_with("public ") || trimmed.starts_with("}") || trimmed.starts_with("Code:") || trimmed.starts_with("descriptor:") || trimmed.starts_with("flags:") {
                skip = false;
                out.push(line);
                continue;
            }
            continue;
        }
        out.push(line);
    }
    out.join("\n")
}

fn normalize_cp_indices(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    let mut it = s.chars().peekable();
    while let Some(ch) = it.next() {
        if ch == '#' {
            let mut saw_digit = false;
            while let Some(&next) = it.peek() {
                if next.is_ascii_digit() { saw_digit = true; it.next(); } else { break; }
            }
            if saw_digit { out.push_str("#X"); } else { out.push('#'); }
        } else {
            out.push(ch);
        }
    }
    out
}

fn collapse_spaces(s: &str) -> String {
    // Normalize: collapse spaces and tabs, drop CRs, and trim trailing spaces per line
    let mut out = String::with_capacity(s.len());
    let mut prev_space = false;
    for ch in s.chars() {
        if ch == '\r' { continue; }
        let is_space = ch == ' ' || ch == '\t';
        if is_space {
            if !prev_space { out.push(' '); }
            prev_space = true;
        } else {
            out.push(ch);
            prev_space = false;
        }
    }
    // Trim trailing spaces on each line
    out
        .lines()
        .map(|l| l.trim_end())
        .collect::<Vec<_>>()
        .join("\n")
}

/// Test enhanced HelloWorld variant with multiple methods and fields
#[test]
fn test_enhanced_helloworld() {
    let source = r#"
public class EnhancedHelloWorld {
    private static int counter = 0;
    
    public static void main(String[] args) {
        System.out.println("Hello, World!");
        incrementCounter();
        System.out.println("Counter: " + counter);
    }
    
    private static void incrementCounter() {
        counter++;
    }
    
    public static int getCounter() {
        return counter;
    }
"#;
    
    // Parse source code
    let ast = parse_tol(source).expect("Failed to parse EnhancedHelloWorld source");
    
    // Find EnhancedHelloWorld class declaration
    let class_decl = ast.type_decls.iter()
        .find_map(|t| match t {
            TypeDecl::Class(c) if c.name == "EnhancedHelloWorld" => Some(c),
            _ => None
        })
        .expect("EnhancedHelloWorld class not found in AST");
    
    // Create ClassWriter and generate class file
    let mut class_writer = ClassWriter::new();
    class_writer.generate_class(class_decl).expect("Failed to generate class");
    
    // Get generated class file
    let class_file = class_writer.get_class_file();
    
    // Verify class file structure
    assert!(class_file.methods.len() >= 4, "Expected at least 4 methods, got {}", class_file.methods.len());
    assert!(class_file.fields.len() >= 1, "Expected at least 1 field, got {}", class_file.fields.len());
    
    // Serialize class file to bytes
    let class_bytes = class_file_to_bytes(&class_file);
    
    // Verify generated bytes
    assert!(!class_bytes.is_empty());
    assert!(class_bytes.len() > 100);
    
    // Verify Java class file magic number
    assert_eq!(class_bytes[0..4], [0xCA, 0xFE, 0xBA, 0xBE]);
    
    println!("Successfully generated EnhancedHelloWorld.class with {} bytes", class_bytes.len());
}
