//! Code generation module for Terminos Language
//! 
//! This module handles the conversion of AST nodes into Java bytecode (.class files).

mod bytecode;
mod class_writer;
mod method_writer;

pub use bytecode::*;
pub use class_writer::*;
pub use method_writer::*;

use crate::ast::*;
use crate::error::{Result, Error};
use crate::config::Config;
use std::path::Path;

/// Generate Java bytecode from an AST
pub fn generate_bytecode(ast: &Ast, output_dir: &str, _config: &Config) -> Result<()> {
    let output_path = Path::new(output_dir);
    
    // Ensure output directory exists
    std::fs::create_dir_all(output_path)?;
    
    // Generate bytecode for each type declaration
    for type_decl in &ast.type_decls {
        match type_decl {
            TypeDecl::Class(class) => {
                generate_class_bytecode(class, output_path)?;
            }
            TypeDecl::Interface(interface) => {
                generate_interface_bytecode(interface, output_path)?;
            }
            TypeDecl::Enum(enum_decl) => {
                generate_enum_bytecode(enum_decl, output_path)?;
            }
            TypeDecl::Annotation(annotation) => {
                generate_annotation_bytecode(annotation, output_path)?;
            }
        }
    }
    
    Ok(())
}

/// Generate bytecode for a class declaration
fn generate_class_bytecode(class: &ClassDecl, output_dir: &Path) -> Result<()> {
    let mut class_writer = ClassWriter::new();
    
    // Generate the class bytecode using the existing method
    class_writer.generate_class(class)?;
    
    // Get the generated class file and write it
    let class_file = class_writer.get_class_file();
    let class_file_path = output_dir.join(format!("{}.class", class.name));
    
    // TODO: Implement writing the class file to disk
    // For now, just return success
    println!("Generated bytecode for class: {}", class.name);
    
    Ok(())
}

/// Generate bytecode for an interface declaration
fn generate_interface_bytecode(interface: &InterfaceDecl, output_dir: &Path) -> Result<()> {
    let mut class_writer = ClassWriter::new();
    
    // Generate the interface bytecode
    class_writer.generate_interface(interface)?;
    
    // Get the generated class file and write it
    let class_file = class_writer.get_class_file();
    let class_file_path = output_dir.join(format!("{}.class", interface.name));
    
    // TODO: Implement writing the class file to disk
    // For now, just return success
    println!("Generated bytecode for interface: {}", interface.name);
    
    Ok(())
}

/// Generate bytecode for an enum declaration
fn generate_enum_bytecode(enum_decl: &EnumDecl, output_dir: &Path) -> Result<()> {
    let mut class_writer = ClassWriter::new();
    
    // Generate the enum bytecode
    class_writer.generate_enum(enum_decl)?;
    
    // Get the generated class file and write it
    let class_file = class_writer.get_class_file();
    let class_file_path = output_dir.join(format!("{}.class", enum_decl.name));
    
    // TODO: Implement writing the class file to disk
    // For now, just return success
    println!("Generated bytecode for enum: {}", enum_decl.name);
    
    Ok(())
}

/// Generate bytecode for an annotation declaration
fn generate_annotation_bytecode(annotation: &AnnotationDecl, output_dir: &Path) -> Result<()> {
    let mut class_writer = ClassWriter::new();
    
    // Generate the annotation bytecode
    class_writer.generate_annotation(annotation)?;
    
    // Get the generated class file and write it
    let class_file = class_writer.get_class_file();
    let class_file_path = output_dir.join(format!("{}.class", annotation.name));
    
    // TODO: Implement writing the class file to disk
    // For now, just return success
    println!("Generated bytecode for annotation: {}", annotation.name);
    
    Ok(())
}

/// Helper function to convert modifiers to bytecode flags
fn modifiers_to_flags(modifiers: &[Modifier]) -> u16 {
    let mut flags = 0;
    
    for modifier in modifiers {
        match modifier {
            Modifier::Public => flags |= 0x0001,      // ACC_PUBLIC
            Modifier::Private => flags |= 0x0002,     // ACC_PRIVATE
            Modifier::Protected => flags |= 0x0004,   // ACC_PROTECTED
            Modifier::Static => flags |= 0x0008,      // ACC_STATIC
            Modifier::Final => flags |= 0x0010,       // ACC_FINAL
            Modifier::Abstract => flags |= 0x0400,    // ACC_ABSTRACT
            Modifier::Native => flags |= 0x0100,      // ACC_NATIVE
            Modifier::Synchronized => flags |= 0x0020, // ACC_SYNCHRONIZED
            Modifier::Transient => flags |= 0x0080,   // ACC_TRANSIENT
            Modifier::Volatile => flags |= 0x0040,    // ACC_VOLATILE
            Modifier::Strictfp => flags |= 0x0800,    // ACC_STRICT
            _ => {}
        }
    }
    
    flags
}
