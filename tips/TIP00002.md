# TIP00002 — Wire `rt.rs` into `method_writer.rs` (kill hardcoding, use real JDK signatures)

**Goal.** Replace heuristic/“hardcoded” field descriptors with real ones from the generated **`rt.rs`** (built from `rt.jar`). Keep a tiny local overlay for your own `java/base/*` structs. Optional section shows how to extend to **method** resolution.

---

## 1) Include `rt.rs` in your crate

done

---

## 2) Add a tiny overlay for **your own classes** (not in `rt.jar`)

These are your `java/base/*` structs like `FieldData`, `MethodData`. Keep them in `method_writer.rs` (above the resolver functions):

```rust
#[derive(Copy, Clone)]
struct LocalField { name: &'static str, desc: &'static str }

fn local_overlay_fields(owner: &str) -> Option<&'static [LocalField]> {
    match owner {
        "java/base/FieldData" => Some(&[
            LocalField { name: "flags",     desc: "I"  },
            LocalField { name: "nameIndex", desc: "I"  },
            LocalField { name: "specIndex", desc: "I"  },
        ]),
        "java/base/MethodData" => Some(&[
            LocalField { name: "flags",     desc: "I"  },
            LocalField { name: "nameIndex", desc: "I"  },
            LocalField { name: "specIndex", desc: "I"  },
            LocalField { name: "code",      desc: "[B" },
        ]),
        _ => None,
    }
}
```

---

## 3) Replace your `resolve_field_descriptor` with a **real lookup** via `rt.rs`

> Handles: array `length` special case; local overlay; walk super chain; (optional) scan interfaces for static finals; conservative fallback.

```rust
/// Resolve field descriptor from generated rt.rs index, with local overlay fallback.
/// `class_internal` must be an internal name like "java/io/OutputStream" or "java/base/FieldData".
fn resolve_field_descriptor(&self, class_internal: &str, field_name: &str) -> String {
    // 1) Arrays don't have fields; `length` is a special property (returns int).
    if class_internal.starts_with('[') && field_name == "length" {
        return "I".to_string();
    }

    // 2) Project-local overlay for types not present in rt.jar
    if let Some(fields) = local_overlay_fields(class_internal) {
        if let Some(f) = fields.iter().find(|f| f.name == field_name) {
            return f.desc.to_string();
        }
    }

    use boot::{CLASSES, CLASSES_BY_NAME};

    // helper: search a single owner in rt.rs
    let mut search_owner = |owner: &str, name: &str| -> Option<&'static str> {
        if let Some(&idx) = CLASSES_BY_NAME.get(owner) {
            let c = &CLASSES[idx];
            if let Some(fm) = c.fields.iter().find(|fm| fm.name == name) {
                return Some(fm.desc);
            }
        }
        None
    };

    // 3a) Walk class → super chain
    let mut cur = Some(class_internal);
    while let Some(owner) = cur {
        if let Some(desc) = search_owner(owner, field_name) {
            return desc.to_string();
        }
        // ascend to super, if any
        cur = boot::CLASSES_BY_NAME
            .get(owner)
            .and_then(|&idx| boot::CLASSES[idx].super_internal);
    }

    // 3b) (Optional) scan direct interfaces for static finals (rare but harmless)
    if let Some(&idx0) = CLASSES_BY_NAME.get(class_internal) {
        for itf in CLASSES[idx0].interfaces {
            if let Some(desc) = search_owner(itf, field_name) {
                return desc.to_string();
            }
        }
    }

    // 4) Last resort fallback; consider making this a hard error to catch misses.
    // eprintln!("Unresolved field {}#{}; fallback to Ljava/lang/String;", class_internal, field_name);
    "Ljava/lang/String;".to_string()
}
```

**Why this works**

* `rt.rs` records **erased JVM descriptors** straight from `.class` files. No generics/overload headaches.
* We query exact owner first, then its `super_internal`, which mirrors JVM lookup rules for fields.

---

## 4) (Optional) Method resolution using `rt.rs` (skeleton)

If you also want to remove method-call hardcoding, adopt a tiny resolver:

```rust
/// Minimal arity counter (quick filter). Switch to slot-count if needed.
fn count_params(desc: &str) -> usize {
    let bytes = desc.as_bytes();
    let mut i = 0usize;
    assert!(bytes[i] == b'('); i += 1;
    let mut n = 0usize;
    while bytes[i] != b')' {
        match bytes[i] {
            b'B'|b'C'|b'F'|b'I'|b'S'|b'Z'|b'J'|b'D' => { n += 1; i += 1; }
            b'[' => {
                i += 1; while bytes[i] == b'[' { i += 1; }
                if bytes[i] == b'L' { while bytes[i] != b';' { i += 1; } i += 1; } else { i += 1; }
                n += 1;
            }
            b'L' => { while bytes[i] != b';' { i += 1; } i += 1; n += 1; }
            _ => break,
        }
    }
    n
}

pub struct ResolvedMethod<'a> {
    pub owner_internal: &'a str,
    pub name: &'a str,
    pub desc: &'a str,
    pub is_interface: bool,
    pub flags: u16, // ACC_STATIC/PRIVATE/etc
}

/// Resolve by walking owner → super chain. You can refine to slot-count/strict match later.
fn resolve_method<'a>(
    owner_internal: &'a str,
    name: &str,
    expected_arity: usize, // or compute from your call-site arg types
) -> Option<ResolvedMethod<'a>> {
    use boot::{CLASSES, CLASSES_BY_NAME};
    let mut cur = Some(owner_internal);
    while let Some(o) = cur {
        if let Some(&idx) = CLASSES_BY_NAME.get(o) {
            let c = &CLASSES[idx];
            if let Some(m) = c.methods.iter().find(|m| m.name == name && count_params(m.desc) == expected_arity) {
                return Some(ResolvedMethod {
                    owner_internal: c.internal,
                    name: m.name,
                    desc: m.desc,
                    is_interface: c.is_interface,
                    flags: m.flags,
                });
            }
            cur = c.super_internal;
        } else {
            break;
        }
    }
    None
}
```

Then inside your emitter:

```rust
if let Some(res) = resolve_method(owner_internal, method_name, arg_arity) {
    // choose invoke* by res.is_interface / res.flags
    // add CP refs for (owner_internal, name, desc)
    // update frames.after_invoke(res.desc)
} else {
    // hard error is better than guessing
}
```

> For perfect parity, switch to **slot-count** matching (long/double = 2), which you might already have as `descriptor::arg_slot_count`.

---

## 5) PR-style patch (minimal changes) — **replace your current function**

```diff
diff --git a/src/method_writer.rs b/src/method_writer.rs
@@
+mod boot {
+    // Adjust this path to where your generator wrote rt.rs
+    include!("generated/rt.rs");
+}
+
+#[derive(Copy, Clone)]
+struct LocalField { name: &'static str, desc: &'static str }
+
+fn local_overlay_fields(owner: &str) -> Option<&'static [LocalField]> {
+    match owner {
+        "java/base/FieldData" => Some(&[
+            LocalField { name: "flags",     desc: "I"  },
+            LocalField { name: "nameIndex", desc: "I"  },
+            LocalField { name: "specIndex", desc: "I"  },
+        ]),
+        "java/base/MethodData" => Some(&[
+            LocalField { name: "flags",     desc: "I"  },
+            LocalField { name: "nameIndex", desc: "I"  },
+            LocalField { name: "specIndex", desc: "I"  },
+            LocalField { name: "code",      desc: "[B" },
+        ]),
+        _ => None,
+    }
+}
+
 /// Resolve field descriptor for a field in a class
-fn resolve_field_descriptor(&self, class_name: &str, field_name: &str) -> String {
-    // Handle specific known classes and their fields
-    match class_name {
-        "java/base/FieldData" => {
-            match field_name {
-                "flags" | "nameIndex" | "specIndex" => "I".to_string(),
-                _ => "Ljava/lang/String;".to_string(),
-            }
-        }
-        "java/base/MethodData" => {
-            match field_name {
-                "flags" | "nameIndex" | "specIndex" => "I".to_string(),
-                "code" => "[B".to_string(),
-                _ => "Ljava/lang/String;".to_string(),
-            }
-        }
-        _ => {
-            // General field type resolution based on naming conventions
-            match field_name {
-                "value" | "count" | "size" | "length" | "index" | "id" | "flags" | "nameIndex" | "specIndex" => "I".to_string(),
-                "name" | "message" | "text" | "description" => "Ljava/lang/String;".to_string(),
-                "enabled" | "active" | "visible" | "valid" => "Z".to_string(),
-                "data" | "content" | "buffer" | "array" | "code" => "[B".to_string(),
-                _ => "Ljava/lang/String;".to_string(), // More specific than Object for safety
-            }
-        }
-    }
-}
+fn resolve_field_descriptor(&self, class_internal: &str, field_name: &str) -> String {
+    if class_internal.starts_with('[') && field_name == "length" {
+        return "I".to_string();
+    }
+    if let Some(fields) = local_overlay_fields(class_internal) {
+        if let Some(f) = fields.iter().find(|f| f.name == field_name) {
+            return f.desc.to_string();
+        }
+    }
+    use boot::{CLASSES, CLASSES_BY_NAME};
+    let mut search_owner = |owner: &str, name: &str| -> Option<&'static str> {
+        if let Some(&idx) = CLASSES_BY_NAME.get(owner) {
+            let c = &CLASSES[idx];
+            if let Some(fm) = c.fields.iter().find(|fm| fm.name == name) {
+                return Some(fm.desc);
+            }
+        }
+        None
+    };
+    let mut cur = Some(class_internal);
+    while let Some(owner) = cur {
+        if let Some(desc) = search_owner(owner, field_name) {
+            return desc.to_string();
+        }
+        cur = boot::CLASSES_BY_NAME
+            .get(owner)
+            .and_then(|&idx| boot::CLASSES[idx].super_internal);
+    }
+    if let Some(&idx0) = CLASSES_BY_NAME.get(class_internal) {
+        for itf in CLASSES[idx0].interfaces {
+            if let Some(desc) = search_owner(itf, field_name) {
+                return desc.to_string();
+            }
+        }
+    }
+    "Ljava/lang/String;".to_string()
+}
```

---

## 6) Test checklist

* `cargo clean && cargo check`
* rust-analyzer → **Reload Workspace**
* Verify that:

  * `FieldData.flags/nameIndex/specIndex` resolve to `I`
  * `MethodData.code` resolves to `[B`
  * `OutputStream.write` later sees `([B)V` if you wire method resolver
  * No more guessing based on field-name heuristics

---

## 7) Troubleshooting

* **`error[E0432]: unresolved import phf::phf_map`**
  Use the macro fully qualified; make sure `phf` is compiled with `features = ["macros"]`. The generated `rt.rs` should **not** import `phf_map`.

* **`cannot find file generated/rt.rs`**
  Check the `include!(...)` path. If you want to auto-generate in builds, move the Python into a `build.rs` process and `include!(concat!(env!("OUT_DIR"), "/rt.rs"))`.

* **Array field `length`**
  Not a field; it’s a special property. Keep the explicit `I` return for `length` on array types.

---

**Done.** With this in, your field descriptors come from the *real JDK signatures*, and you can incrementally extend the same pattern to method resolution (`emit_invoke` stays unchanged; pass it the resolved `{owner, name, desc, is_interface, flags}`).
