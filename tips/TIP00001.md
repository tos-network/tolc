
# TIP00001 — Make `tolc` classfiles match `javac` (case study: `Assembler.java`)

**Scope:** This note distills the concrete gaps seen in the uploaded `javap -verbose` diff for `java.base.Assembler` (compiled by **tolc** vs **javac**) and maps them to fixes inside your current codegen. It’s written to be **Cursor‑friendly** and actionable across your existing files.

---

## 0) What the diff tells us (symptoms)

From the “ours” (tolc) vs “ref” (javac) sections:

1. **Wrong owners/descriptors in calls and fields**
   - `Method java/lang/Object.addUtf8:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;`
   - `Method write4:(Ljava/lang/Object;I)Ljava/lang/Object;`
   - `getfield #X // Field ConstantPool:Ljava/lang/Object;`
   > In the ref, these are:
   - `Method java/base/ConstantPool.addUtf8:(Ljava/util/List;Ljava/lang/String;)I`
   - `Method java/base/Stream.write4:(Ljava/io/OutputStream;I)V`
   - No such `getfield` on the `OutputStream` arg.

   **Interpretation:** owner class resolution is falling back to `java/lang/Object`; return/param descriptors default to `Ljava/lang/Object;` instead of the real types; and an erroneous field access is emitted.

2. **Wrong invoke opcodes**
   - tol c uses `invokevirtual` for methods that are `invokestatic` in the ref.
   - Missing/incorrect `invokeinterface` form (the ref uses `invokeinterface #X, N` with proper arg count).

3. **Static vs instance locals mislayout**
   - tol c bytecode for a `public static void writeClass(...)` uses `aload_0` and even `getfield` — as if there were a `this`.
   - This points to **args_size / local 0** being treated like an instance method.

4. **Control flow junk**
   - Spurious `goto <same-pc>` or `goto` into `nop` blocks, suggesting loop translation or label management is off (infinite/self jumps).

5. **Misc**
   - Some constant values and field lists line up fine (e.g., opcodes), so the issue is focused on **reference resolution, call kind, locals layout, and control flow**.

---

## 1) Root cause map → your code

| Symptom | Likely Cause | Files to touch |
|---|---|---|
| Owners/desc default to `java/lang/Object` | Name/descriptor resolver falls back to Object on miss; N&T construction doesn’t use the resolved type | `classpath.rs`, `descriptor.rs`, `constpool.rs`, `signature.rs` |
| Wrong invoke opcodes | Call kind isn’t computed (static/interface/special/virtual) | `method_writer.rs`, `opcode_generator.rs`, `opcodes.rs`, `frame.rs` (stack effect) |
| `this` used in static method | args layout not honoring `static` (or `MethodDecl.modifiers` not propagated) | `method_writer.rs` (parameter init & var indexing), verify parser/AST |
| Bad loops / `goto` | Label allocator and forward-branch patching; while/for lowering | `bytecode.rs` (builder), `method_writer.rs` (stmt lowering) |
| Interface call operands | `invokeinterface` needs `count` (= arg slots incl. receiver) + trailing zero | `opcode_generator.rs`, `method_writer.rs`, `descriptor.rs` |

---

## 2) High‑impact fixes (do these first)

### A) **Never default to `java/lang/Object` for owners or descriptors**
- In `classpath.rs`: when resolution fails for a type or member, **emit a compiler error**; do **not** silently map to `java/lang/Object`.
- In `descriptor.rs` / `signature.rs`:
  - Ensure method returns are encoded correctly: `void` → `V`, not `Ljava/lang/Void;`.
  - Map source names to **internal** names (`java.base.Stream` → `java/base/Stream`). Centralize this in one helper.
- In `constpool.rs`:
  - `try_add_method_ref(class, name, desc)` and friends must use the **resolved internal owner** and **exact descriptor**. Remove any Object fallback paths.
  - If you haven’t yet, implement/verify **two‑slot** padding for `Long`/`Double` and **Utf8 ≤ 65,535 (modified UTF‑8)** checks (you have TODOs from my previous note).

### B) **Correct call opcode selection**
Add a single function in `method_writer.rs`:

```rust
fn emit_invoke(&mut self, callee: &ResolvedMethod) -> Result<()> {
    use super::opcodes::*;
    let idx = self.cp_mut()?.try_add_method_ref(&callee.owner_internal, &callee.name, &callee.descriptor)?;
    let op = if callee.is_interface {
        INVOKEINTERFACE
    } else if callee.is_static {
        INVOKESTATIC
    } else if callee.is_ctor || callee.is_private || callee.is_super_call {
        INVOKESPECIAL
    } else {
        INVOKEVIRTUAL
    };
    self.bytecode_builder.emit_u8(op);
    self.bytecode_builder.emit_u16(idx);
    if op == INVOKEINTERFACE {
        let argc = descriptor_arg_slot_count(&callee.descriptor); // includes receiver
        self.bytecode_builder.emit_u8(argc as u8);
        self.bytecode_builder.emit_u8(0); // per JVM spec
    }
    self.stack_after_invoke(&callee.descriptor)?; // update frame/stack
    Ok(())
}
```

- Implement `descriptor_arg_slot_count` in `descriptor.rs` (pay attention to `long`/`double`=2 slots).
- In your call-expression lowering, **always go through `emit_invoke`**.

### C) **Static vs instance locals**
In `method_writer.rs`:
- During method entry, compute an **ArgLayout**:

```rust
struct ArgLayout { is_static: bool, next_local: u16 /* after args */ }

fn compute_arg_layout(desc: &MethodDescriptor, flags: u16) -> ArgLayout {
    let is_static = flags & ACC_STATIC != 0;
    let mut next = 0;
    if !is_static { next += 1; } // this
    for arg in desc.args.iter() {
        next += if arg.is_long_or_double() { 2 } else { 1 };
    }
    ArgLayout { is_static, next_local: next }
}
```

- Use `ArgLayout` to index parameters and to set `max_locals` minimum.
- **Never** emit `aload_0` in a static method unless you’re loading the first formal parameter and it happens to be an `Object` — which still requires using the **correct index**, not `0`.

### D) **Interface call operands**
- In `opcode_generator.rs`, expose a helper:

```rust
pub fn invokeinterface(&self, index: u16, count: u8) -> Vec<u8> {
    vec![opcodes::INVOKEINTERFACE, (index >> 8) as u8, (index & 0xFF) as u8, count, 0]
}
```

- Ensure `count` is **1 (receiver) + sum(arg slots)** for non‑static interface calls.

### E) **Branch/label sanity**
- In `bytecode.rs` (or wherever `BytecodeBuilder` lives): assert that `goto` targets are **different** from current PC; warn/fail fast on self‑jumps.
- When lowering `for`/`while`, use a canonical pattern: `init; goto test; loop: body; incr; test: if(<cond>) goto loop`. Verify label IDs are unique and patching occurs exactly once.

---

## 3) File‑by‑file TODOs (surgical edits)

### `method_writer.rs`
- [ ] Add `emit_invoke` (above) and replace all direct invoke emission.
- [ ] Introduce `ArgLayout` at start of method generation; set `max_locals = max(max_locals, layout.next_local)`.
- [ ] Respect `Modifier::Static` when deciding whether to allocate `"this"`.
- [ ] When lowering variable loads/stores, use the computed parameter indices, not hardcoded `aload_0` etc.
- [ ] Ensure return op matches descriptor (`IRETURN`, `ARETURN`, `RETURN`, etc.).

### `frame.rs`
- [ ] Provide `descriptor_arg_slot_count` or a shared utility.
- [ ] Update stack simulation in `after_invoke` to pop args (and receiver for non‑static) and push return category (void/1/2).
- [ ] Validate `max_stack` against simulated peak; fail with a clear error if mismatch.

### `descriptor.rs` / `signature.rs`
- [ ] Encode `void` → `V`; primitives `[BCDFIJSZ]`; arrays `'[' + type`; refs `'L<internal>;'`.
- [ ] Add `to_internal_name("java.base.Stream") -> "java/base/Stream"` and use it everywhere.
- [ ] Implement `arg_slot_count()` and `ret_category()` helpers.

### `classpath.rs`
- [ ] Resolve the **declaring class** of each referenced method/field, including static imports.
- [ ] Do **not** fall back to `java/lang/Object`. Emit a typed error if unresolved.

### `constpool.rs`
- [ ] Ensure `try_add_*ref` uses the **resolved internal owner** and **exact N&T**.
- [ ] Keep earlier fixes: Utf8 length guard, two‑slot padding for `Long`/`Double`, no `.unwrap()` in hot paths.

### `opcode_generator.rs` / `opcodes.rs`
- [ ] Define all invoke helpers; verify `invokeinterface`’s 5‑byte operand format.
- [ ] Add typed wrappers that take `ConstPoolIndex<MethodRef>` etc. (you already have `typed_index.rs` — use it here).

### `bytecode.rs` (builder)
- [ ] Dedup labels; prohibit self‑gotos; add unit tests for while/for lowering to avoid `goto X` → `X`.
- [ ] Provide `emit_branch(op, label)` that records patch sites; patch once.

### `method.rs` / `field.rs`
- [ ] Verify descriptors are built from `descriptor.rs` (not hand‑rolled).
- [ ] Attribute order: emit `Code` first on methods, then debug attributes; `ConstantValue` on `static final` fields only.

---

## 4) Minimal repro tests to add now

- **Golden compile** of `Assembler.java`; run `javap -verbose` on both jars; compare:
  - Every `Method ...write2/write4` call must be `invokestatic` on `java/base/Stream` and **descriptor** must be `(Ljava/io/OutputStream;I)V`.
  - Ensure **no** `getfield ConstantPool` exists in `writeClass` (there is no such field).
  - Verify `args_size` equals the number of parameters for static methods (no `this`).

- Add micro tests:
  - Static vs instance: `static void f(int)` vs `void f(int)` → first must not use local 0 as `this`.
  - Interface call: `List.size()` emits `invokeinterface ..., 1` (receiver only).

---

## 5) Rollout order

1. Descriptor/owner correctness (A) → constant pool refs become accurate.
2. Invoke selection (B, D) → correct opcodes & operands.
3. Locals layout (C) → remove phantom `this`.
4. Branching sanity (E) → eliminate self‑loops.
5. Tighten CP/UTF8/two‑slot rules (carryover from TIP00000).

---

## 6) Quick smoke checklist (paste into CI)

- [ ] No occurrence of `java/lang/Object.addUtf8` in output classfiles.
- [ ] No `Method write2:(Ljava/lang/Object;I)Ljava/lang/Object;` anywhere.
- [ ] All `Stream.write2/4` sites are `invokestatic` with `(Ljava/io/OutputStream;I)V`.
- [ ] No `aload_0` in any `ACC_STATIC` method body (unless the first parameter is intentionally loaded by **its** index).
- [ ] No `goto` to current PC.

---

## 7) Notes

- If the parser isn’t setting `Modifier::Static`, fix that at the AST layer — the codegen changes above assume the flag is correct.
- Do not skip compile errors by “Object fallback”; it makes debugging impossible and causes the exact corruption seen in this diff.

---

**End of TIP00001**
